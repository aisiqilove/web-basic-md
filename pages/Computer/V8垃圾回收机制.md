## V8垃圾回收机制

### 什么是垃圾回收

**垃圾回收**（Garbage Collection）是一种自动内存管理机制，它可以自动回收不再使用的内存，释放给程序使用。

### 为什么需要垃圾回收

在 C/C++ 中，我们需要手动申请内存和释放内存，这样做的好处是可以精确地控制内存的使用，但是也会带来一些问题：

* 申请内存和释放内存的操作容易出错，容易造成内存泄漏和内存溢出

* 申请内存和释放内存的操作会耗费一定的时间

* 申请内存和释放内存的操作需要占用一定的内存空间

所以，为了解决这些问题，就有了垃圾回收机制。

### 垃圾回收的原理

垃圾回收机制的原理是：**找出那些不再使用的变量，然后释放其占用的内存空间**。

在 V8 中，垃圾回收机制的实现是：**标记清除（Mark-Sweep）算法**。

### 标记清除算法

标记清除算法的原理是：**将内存中的所有变量分为两个集合，一个是可达集合，一个是不可达集合**。

* 可达集合：内存中正在使用的变量

* 不可达集合：内存中不再使用的变量

**标记清除算法的步骤：**

1.  首先，将所有变量都标记为不可达集合

2.  然后，从根变量开始遍历，将所有可达的变量都标记为可达集合

3.  最后，将不可达集合中的变量清除

### V8 的垃圾回收机制

V8 的垃圾回收机制是基于分代式垃圾回收机制的，所谓分代式垃圾回收机制，就是将内存中的对象分为两个代：**新生代和老生代**。

* 新生代：存放生存时间短的对象

* 老生代：存放生存时间长的对象

**V8 的垃圾回收机制的原理是：**根据对象的生存周期的不同来应用不同的回收算法。

### 新生代的垃圾回收

**新生代的垃圾回收的特点：**

* 新生代中的对象生存时间短

* 新生代中的对象占用的内存空间小

**新生代的垃圾回收的算法：****Scavenge 算法**

**Scavenge 算法的原理：**将新生代中的对象分为两个区域：**From 空间和 To 空间**。

* From 空间：存放正在使用的对象

* To 空间：闲置的空间

**Scavenge 算法的步骤：**

1.  首先，将 From 空间中的对象复制到 To 空间中

2.  然后，将 From 空间和 To 空间互换

3.  最后，将 From 空间中的对象清除

**Scavenge 算法的优缺点：**

* 优点：实现简单，执行效率高

* 缺点：只能使用堆内存的一半空间

### 老生代的垃圾回收

**老生代的垃圾回收的特点：**

* 老生代中的对象生存时间长

* 老生代中的对象占用的内存空间大

**老生代的垃圾回收的算法：****Mark-Sweep（标记清除算法） 算法和 Mark-Compact（标记压缩） 算法**

**Mark-Sweep 算法的原理：**将内存中的所有变量分为两个集合，一个是可达集合，一个是不可达集合。

* 可达集合：内存中正在使用的变量

* 不可达集合：内存中不再使用的变量

**Mark-Sweep 算法的步骤：**

1.  首先，将所有变量都标记为不可达集合

2.  然后，从根变量开始遍历，将所有可达的变量都标记为可达集合

3.  最后，将不可达集合中的变量清除

**Mark-Sweep 算法的优缺点：**

* 优点：实现简单

* 缺点：会造成内存碎片

**Mark-Compact 算法的原理：**将内存中的所有变量分为两个集合，一个是可达集合，一个是不可达集合。

* 可达集合：内存中正在使用的变量

* 不可达集合：内存中不再使用的变量

**Mark-Compact 算法的步骤：**

1.  首先，将所有变量都标记为不可达集合

2.  然后，从根变量开始遍历，将所有可达的变量都标记为可达集合

3.  最后，将可达集合中的变量向一端移动，然后清除另一端的所有变量

**Mark-Compact 算法的优缺点：**

* 优点：不会造成内存碎片

* 缺点：实现复杂，执行效率低

### V8 的垃圾回收机制的优化

**V8 的垃圾回收机制的优化的原理是：**根据对象的生存周期的不同来应用不同的回收算法。

**V8 的垃圾回收机制的优化的步骤：**

1.  首先，将内存中的对象分为两个代：新生代和老生代

2.  然后，将新生代中的对象使用 Scavenge 算法回收

3.  最后，将老生代中的对象使用 Mark-Sweep 算法和 Mark-Compact 算法回收

**V8 的垃圾回收机制的优化的优点：**

* 优点：实现简单，执行效率高

* 优点：不会造成内存碎片

* 优点：可以使用堆内存的一半空间

**V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿。**

**为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法**